Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id BE36E29A5BC
	for <lists+linux-kernel@lfdr.de>; Tue, 27 Oct 2020 08:47:28 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2508055AbgJ0HqG (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Tue, 27 Oct 2020 03:46:06 -0400
Received: from mx2.suse.de ([195.135.220.15]:45856 "EHLO mx2.suse.de"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S2508047AbgJ0HqG (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 27 Oct 2020 03:46:06 -0400
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
        by mx2.suse.de (Postfix) with ESMTP id 18D0FAF72;
        Tue, 27 Oct 2020 07:46:05 +0000 (UTC)
Date:   Tue, 27 Oct 2020 08:46:05 +0100
Message-ID: <s5hlffs2jsy.wl-tiwai@suse.de>
From:   Takashi Iwai <tiwai@suse.de>
To:     Kai-Heng Feng <kai.heng.feng@canonical.com>
Cc:     tiwai@suse.com, perex@perex.cz, hui.wang@canonical.com,
        kai.vehmanen@linux.intel.com, alsa-devel@alsa-project.org,
        linux-kernel@vger.kernel.org
Subject: Re: [PATCH v2 3/4] ALSA: hda: Separate runtime and system suspend
In-Reply-To: <20201027054001.1800-4-kai.heng.feng@canonical.com>
References: <20201027054001.1800-1-kai.heng.feng@canonical.com>
        <20201027054001.1800-4-kai.heng.feng@canonical.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, 27 Oct 2020 06:40:00 +0100,
Kai-Heng Feng wrote:
> @@ -1002,7 +1001,8 @@ static void __azx_runtime_resume(struct azx *chip, bool from_rt)
>  	azx_init_pci(chip);
>  	hda_intel_init_chip(chip, true);
>  
> -	if (from_rt) {
> +	/* Avoid codec resume if runtime resume is for system suspend */
> +	if (from_rt && !chip->prepared) {

The check of chip->prepared is superfluous here.  Its check should be
applied rather at setting WAKEEN, namely...

> @@ -1103,10 +1115,8 @@ static int azx_runtime_suspend(struct device *dev)
>  	chip = card->private_data;
>  
>  	/* enable controller wake up event */
> -	if (snd_power_get_state(card) == SNDRV_CTL_POWER_D0) {
> -		azx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) |
> -			   STATESTS_INT_MASK);
> -	}
> +	azx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) |
> +		   STATESTS_INT_MASK);

... here we should have the check of chip->prepared, and set WAKEEN
only when it's false.  Otherwise WAKEEN is set up for the system
suspend, and it might lead to spurious wakeups.  (IOW, checking the
flag at resume doesn't help for preventing the spurious wakeup :)


thanks,

Takashi
