Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id 106F82F6D6D
	for <lists+linux-kernel@lfdr.de>; Thu, 14 Jan 2021 22:46:06 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1730276AbhANVpZ (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Thu, 14 Jan 2021 16:45:25 -0500
Received: from mail.kernel.org ([198.145.29.99]:50676 "EHLO mail.kernel.org"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1726906AbhANVpY (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 14 Jan 2021 16:45:24 -0500
Received: from disco-boy.misterjones.org (disco-boy.misterjones.org [51.254.78.96])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by mail.kernel.org (Postfix) with ESMTPSA id 9708722BEA;
        Thu, 14 Jan 2021 21:44:43 +0000 (UTC)
Received: from 78.163-31-62.static.virginmediabusiness.co.uk ([62.31.163.78] helo=wait-a-minute.misterjones.org)
        by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        (Exim 4.94)
        (envelope-from <maz@kernel.org>)
        id 1l0AQ5-007bs8-7D; Thu, 14 Jan 2021 21:44:41 +0000
Date:   Thu, 14 Jan 2021 21:44:40 +0000
Message-ID: <87sg73jirb.wl-maz@kernel.org>
From:   Marc Zyngier <maz@kernel.org>
To:     Samuel Holland <samuel@sholland.org>
Cc:     Thomas Gleixner <tglx@linutronix.de>,
        Rob Herring <robh+dt@kernel.org>,
        Maxime Ripard <mripard@kernel.org>,
        Chen-Yu Tsai <wens@csie.org>,
        Jernej Skrabec <jernej.skrabec@siol.net>,
        Ondrej Jirman <megous@megous.com>, devicetree@vger.kernel.org,
        linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org
Subject: Re: [PATCH v4 04/10] irqchip/sun6i-r: Add wakeup support
In-Reply-To: <20210112055950.21209-5-samuel@sholland.org>
References: <20210112055950.21209-1-samuel@sholland.org>
        <20210112055950.21209-5-samuel@sholland.org>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 Emacs/27.1
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=US-ASCII
X-SA-Exim-Connect-IP: 62.31.163.78
X-SA-Exim-Rcpt-To: samuel@sholland.org, tglx@linutronix.de, robh+dt@kernel.org, mripard@kernel.org, wens@csie.org, jernej.skrabec@siol.net, megous@megous.com, devicetree@vger.kernel.org, linux-arm-kernel@lists.infradead.org, linux-kernel@vger.kernel.org
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, 12 Jan 2021 05:59:44 +0000,
Samuel Holland <samuel@sholland.org> wrote:
> 
> Maintain bitmaps of wake-enabled IRQs and mux inputs, and program them
> to the hardware during the syscore phase of suspend and shutdown. Then
> restore the original set of enabled IRQs (only the NMI) during resume.
> 
> This serves two purposes. First, it lets power management firmware
> running on the ARISC coprocessor know which wakeup sources Linux wants
> to have enabled. That way, it can avoid turning them off when it shuts
> down the remainder of the clock tree. Second, it preconfigures the
> coprocessor's interrupt controller, so the firmware's wakeup logic
> is as simple as waiting for an interrupt to arrive.
> 
> The suspend/resume logic is not conditional on PM_SLEEP because it is
> identical to the init/shutdown logic. Wake IRQs may be enabled during
> shutdown to allow powering the board back on. As an example, see
> commit a5c5e50cce9d ("Input: gpio-keys - add shutdown callback").
> 
> Signed-off-by: Samuel Holland <samuel@sholland.org>
> ---
>  drivers/irqchip/irq-sun6i-r.c | 107 ++++++++++++++++++++++++++++++++--
>  1 file changed, 101 insertions(+), 6 deletions(-)
> 
> diff --git a/drivers/irqchip/irq-sun6i-r.c b/drivers/irqchip/irq-sun6i-r.c
> index d04d067423f4..a1b58c98d6ca 100644
> --- a/drivers/irqchip/irq-sun6i-r.c
> +++ b/drivers/irqchip/irq-sun6i-r.c
> @@ -39,6 +39,7 @@
>   * set of 128 mux bits. This requires a second set of top-level registers.
>   */
>  
> +#include <linux/bitmap.h>
>  #include <linux/interrupt.h>
>  #include <linux/irq.h>
>  #include <linux/irqchip.h>
> @@ -46,6 +47,7 @@
>  #include <linux/of.h>
>  #include <linux/of_address.h>
>  #include <linux/of_irq.h>
> +#include <linux/syscore_ops.h>
>  
>  #include <dt-bindings/interrupt-controller/arm-gic.h>
>  
> @@ -67,8 +69,17 @@
>  #define SUN6I_NR_DIRECT_IRQS		16
>  #define SUN6I_NR_MUX_BITS		128
>  
> +struct sun6i_r_intc_variant {
> +	u32		first_mux_irq;
> +	u32		nr_mux_irqs;
> +	u32		mux_valid[BITS_TO_U32(SUN6I_NR_MUX_BITS)];
> +};
> +
>  static void __iomem *base;
>  static irq_hw_number_t nmi_hwirq;
> +static DECLARE_BITMAP(wake_irq_enabled, SUN6I_NR_TOP_LEVEL_IRQS);
> +static DECLARE_BITMAP(wake_mux_enabled, SUN6I_NR_MUX_BITS);
> +static DECLARE_BITMAP(wake_mux_valid, SUN6I_NR_MUX_BITS);
>  
>  static void sun6i_r_intc_ack_nmi(void)
>  {
> @@ -145,6 +156,21 @@ static int sun6i_r_intc_nmi_set_irqchip_state(struct irq_data *data,
>  	return irq_chip_set_parent_state(data, which, state);
>  }
>  
> +static int sun6i_r_intc_irq_set_wake(struct irq_data *data, unsigned int on)
> +{
> +	unsigned long offset_from_nmi = data->hwirq - nmi_hwirq;
> +
> +	if (offset_from_nmi < SUN6I_NR_DIRECT_IRQS)
> +		assign_bit(offset_from_nmi, wake_irq_enabled, on);
> +	else if (test_bit(data->hwirq, wake_mux_valid))
> +		assign_bit(data->hwirq, wake_mux_enabled, on);
> +	else
> +		/* Not wakeup capable. */
> +		return -EPERM;
> +
> +	return 0;
> +}
> +
>  static struct irq_chip sun6i_r_intc_nmi_chip = {
>  	.name			= "sun6i-r-intc",
>  	.irq_ack		= sun6i_r_intc_nmi_ack,
> @@ -154,8 +180,19 @@ static struct irq_chip sun6i_r_intc_nmi_chip = {
>  	.irq_set_affinity	= irq_chip_set_affinity_parent,
>  	.irq_set_type		= sun6i_r_intc_nmi_set_type,
>  	.irq_set_irqchip_state	= sun6i_r_intc_nmi_set_irqchip_state,
> -	.flags			= IRQCHIP_SET_TYPE_MASKED |
> -				  IRQCHIP_SKIP_SET_WAKE,
> +	.irq_set_wake		= sun6i_r_intc_irq_set_wake,
> +	.flags			= IRQCHIP_SET_TYPE_MASKED,
> +};
> +
> +static struct irq_chip sun6i_r_intc_wakeup_chip = {
> +	.name			= "sun6i-r-intc",
> +	.irq_mask		= irq_chip_mask_parent,
> +	.irq_unmask		= irq_chip_unmask_parent,
> +	.irq_eoi		= irq_chip_eoi_parent,
> +	.irq_set_affinity	= irq_chip_set_affinity_parent,
> +	.irq_set_type		= irq_chip_set_type_parent,
> +	.irq_set_wake		= sun6i_r_intc_irq_set_wake,
> +	.flags			= IRQCHIP_SET_TYPE_MASKED,

Worth implementing irq_get/set_irqchip_state() using the _parent
helper, I guess.

Thanks,

	M.

-- 
Without deviation from the norm, progress is not possible.
