Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id 7961A29A597
	for <lists+linux-kernel@lfdr.de>; Tue, 27 Oct 2020 08:36:50 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S2507821AbgJ0Hgh (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Tue, 27 Oct 2020 03:36:37 -0400
Received: from mx2.suse.de ([195.135.220.15]:42842 "EHLO mx2.suse.de"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1731614AbgJ0Hgh (ORCPT <rfc822;linux-kernel@vger.kernel.org>);
        Tue, 27 Oct 2020 03:36:37 -0400
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay2.suse.de (unknown [195.135.221.27])
        by mx2.suse.de (Postfix) with ESMTP id 58949AEBA;
        Tue, 27 Oct 2020 07:36:35 +0000 (UTC)
Date:   Tue, 27 Oct 2020 08:36:35 +0100
Message-ID: <s5hmu082k8s.wl-tiwai@suse.de>
From:   Takashi Iwai <tiwai@suse.de>
To:     Kai-Heng Feng <kai.heng.feng@canonical.com>
Cc:     tiwai@suse.com, perex@perex.cz, hui.wang@canonical.com,
        kai.vehmanen@linux.intel.com, alsa-devel@alsa-project.org,
        linux-kernel@vger.kernel.org
Subject: Re: [PATCH v2 2/4] ALSA: hda: Stop mangling PCI IRQ
In-Reply-To: <20201027054001.1800-3-kai.heng.feng@canonical.com>
References: <20201027054001.1800-1-kai.heng.feng@canonical.com>
        <20201027054001.1800-3-kai.heng.feng@canonical.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL/10.8 Emacs/25.3
 (x86_64-suse-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

On Tue, 27 Oct 2020 06:39:59 +0100,
Kai-Heng Feng wrote:
> 
> The code predates 2005, it should be unnecessary now as PCI core handles
> IRQ much better nowadays.
> 
> So stop PCI IRQ mangling in suspend/resume callbacks.
> 
> Takashi Iwai mentioned that IRQ number can change after S3 on some
> really old hardwares. We should use quirks to handle those platforms, as
> most modern systems won't have that issue.

I believe it was S4.  And this pretty much depends on BIOS, hence it's
hard to apply the quirk, honestly speaking.

And, if we know that we need a quirk, dropping the code completely now
is a bad move.  If any, this should be applied conditionally to the
"known to be modern" platforms, but this will make the code rather
messier, OTOH.

Do we need this change inevitably?  Otherwise I'd skip this one.


thanks,

Takashi


> 
> Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
> ---
> v2:
>  - Wording.
>  - Add info on IRQ # can change on old hardwares.
> 
>  sound/pci/hda/hda_intel.c | 15 ---------------
>  1 file changed, 15 deletions(-)
> 
> diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
> index 749b88090970..b4aa1dcf1aae 100644
> --- a/sound/pci/hda/hda_intel.c
> +++ b/sound/pci/hda/hda_intel.c
> @@ -1022,13 +1022,11 @@ static int azx_suspend(struct device *dev)
>  {
>  	struct snd_card *card = dev_get_drvdata(dev);
>  	struct azx *chip;
> -	struct hdac_bus *bus;
>  
>  	if (!azx_is_pm_ready(card))
>  		return 0;
>  
>  	chip = card->private_data;
> -	bus = azx_bus(chip);
>  	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
>  	/* An ugly workaround: direct call of __azx_runtime_suspend() and
>  	 * __azx_runtime_resume() for old Intel platforms that suffer from
> @@ -1038,14 +1036,6 @@ static int azx_suspend(struct device *dev)
>  		__azx_runtime_suspend(chip);
>  	else
>  		pm_runtime_force_suspend(dev);
> -	if (bus->irq >= 0) {
> -		free_irq(bus->irq, chip);
> -		bus->irq = -1;
> -		chip->card->sync_irq = -1;
> -	}
> -
> -	if (chip->msi)
> -		pci_disable_msi(chip->pci);
>  
>  	trace_azx_suspend(chip);
>  	return 0;
> @@ -1060,11 +1050,6 @@ static int azx_resume(struct device *dev)
>  		return 0;
>  
>  	chip = card->private_data;
> -	if (chip->msi)
> -		if (pci_enable_msi(chip->pci) < 0)
> -			chip->msi = 0;
> -	if (azx_acquire_irq(chip, 1) < 0)
> -		return -EIO;
>  
>  	if (chip->driver_caps & AZX_DCAPS_SUSPEND_SPURIOUS_WAKEUP)
>  		__azx_runtime_resume(chip, false);
> -- 
> 2.17.1
> 
